#!/usr/bin/python
# Copyright (c) Members of the EGEE Collaboration. 2004. 
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.  
#
# Licensed under the Apache License, Version 2.0 (the "License"); 
# you may not use this file except in compliance with the License. 
# You may obtain a copy of the License at 
#
#     http://www.apache.org/licenses/LICENSE-2.0 
#
# Unless required by applicable law or agreed to in writing, software 
# distributed under the License is distributed on an "AS IS" BASIS, 
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
# See the License for the specific language governing permissions and 
# limitations under the License.

# plugin for gip framework.  generates Glue values associated
# with the scheduler, like FreeSlots or *ResponseTime

import sys
import os
import getopt
import string
import ConfigParser
import shlex
import subprocess

from DynamicSchedulerGeneric import Analyzer
from DynamicSchedulerGeneric import GLUE1Handler
from DynamicSchedulerGeneric import GLUE2Handler


GLUE1FORMAT = 1
GLUE2FORMAT = 2
BOTHFORMAT = 3


def usage():
    print "Usage: lcg-info-dynamic-scheduler -c <cfg_file>"

def abort_without_output(msg):
    print("++++ %s ++++" % msg)
    sys.exit(2)

def getVOMap(config):
    vomap = dict()
    if config.has_option('Main','vomap'):
        lines = config.get('Main','vomap').split('\n')
        for line in lines:
            tmpl = line.split(':')
            if len(tmpl) == 2:
                group = tmpl[0].strip()
                vo = tmpl[1].strip()
                vomap[group] = vo
    return vomap


def getMaxJobsTable(config, vomap):
    if not config.has_option('Scheduler','vo_max_jobs_cmd'):
        return dict()
    
    try:
        raw_cmd = config.get('Scheduler','vo_max_jobs_cmd')
        process = subprocess.Popen(shlex.split(raw_cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (stdoutdata, stderrdata) = process.communicate()
        if process.returncode:
            abort_without_output("VO max jobs backend command returned " + process.returncode)

        #
        # TODO replace with a simple parser, get rid of the eval()
        #
        idx1 = stdoutdata.find("{")
        idx2 = stdoutdata.find("}")
        if idx1 < 0 or idx2 < 0 or idx2 < idx1:
            abort_without_output('Malformed output for %s' % raw_command)
        dictString = stdoutdata[idx1:idx2+1]
        return eval(dictString, {"__builtins__" : {}})
        
    except OSError, os_error:
        abort_without_output('Error running "%s": %s' % (raw_cmd, repr(os_error)))
    except ValueError, value_error:
        abort_without_output('Wrong arguments for "%s": %s' % (raw_cmd, repr(value_error)))
    except Exception, generic_error:
        abort_without_output(repr(generic_error))


def main():

    config = ConfigParser.ConfigParser()

    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:", ["config="])
    except getopt.GetoptError:
        usage()
        abort_without_output("Error parsing command line")

    cfgfile = None

    for o, a in opts:
        if o in ("-c", "--config"):
            cfgfile = a
        
    if not cfgfile:
        usage()
        abort_without_output("No config file specified.")
    
    conffile_desc = None
    try:
        try:
            conffile_desc = open(cfgfile)
            config.readfp(conffile_desc)
        except:
            abort_without_output("While parsing config file: " + cfgfile)
    finally:
        if conffile_desc <> None:
            conffile_desc.close()
    
    outputformat = BOTHFORMAT
    if config.has_option('Main','outputformat'):
        tmps = config.get('Main','outputformat').lower().strip()
        if tmps == "glue1":
            outputformat = GLUE1FORMAT
        elif tmps == "glue2":
            outputformat = GLUE2FORMAT
        elif tmps <> "both":
            abort_without_output("Wrong argument outputformat: " + tmps)
    

    vomap = getVOMap(config)
    mjobTable = getMaxJobsTable(config, vomap)
    print mjobTable
    data = Analyzer.analyze(config, vomap, mjobTable)

    if outputformat & GLUE1FORMAT:
        GLUE1Handler.process(config, vomap)
    
    if outputformat & GLUE2FORMAT:
        GLUE2Handler.process(config, vomap)

if __name__ == "__main__":
    main()
